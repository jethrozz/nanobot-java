# Nanobot-Java 架构设计文档

## 1. 系统架构

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Nanobot-Java                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────┐    ┌───────────────┐    ┌───────────────┐               │
│  │   CLI Layer   │    │  HTTP API     │    │  Management   │               │
│  │  (Picocli)    │    │  (Spring MVC) │    │    (Actuator) │               │
│  └───────┬───────┘    └───────┬───────┘    └───────┬───────┘               │
│          │                    │                    │                       │
│          └────────────────────┼────────────────────┘                       │
│                               ▼                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         Gateway Layer                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐            │   │
│  │  │Router    │  │Auth      │  │RateLimit │  │Metrics   │            │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                               ▼                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Message Bus (Reactor)                           │   │
│  │  ┌──────────────────┐              ┌──────────────────┐             │   │
│  │  │   Inbound Queue  │──────────────▶│  Outbound Queue  │             │   │
│  │  └──────────────────┘              └──────────────────┘             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                               ▼                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          Agent Layer                                │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐           │   │
│  │  │ AgentLoop     │  │ContextBuilder │  │ MemoryManager │           │   │
│  │  │ (核心引擎)     │  │ (上下文构建)   │  │ (记忆管理)     │           │   │
│  │  └───────┬───────┘  └───────┬───────┘  └───────┬───────┘           │   │
│  └──────────┼──────────────────┼──────────────────┼───────────────────┘   │
│             ▼                  ▼                  ▼                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Provider Layer                               │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │GLM       │ │DeepSeek  │ │Qwen      │ │Moonshot  │ │Gateway   │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                               ▲                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         Tool Layer                                   │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │File      │ │Shell     │ │Web       │ │Message   │ │Spawn     │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                               ▲                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Channel Layer                                │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │Feishu    │ │WeCom     │ │QQ        │ │DingTalk  │ │Telegram  │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Infrastructure Layer                            │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │Config    │ │Scheduler │ │Storage   │ │Logging   │ │Security  │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 分层说明

| 层级 | 职责 | 技术栈 |
|------|------|--------|
| CLI Layer | 命令行交互 | Picocli |
| Gateway Layer | 网关、路由、鉴权 | Spring MVC |
| Message Bus | 消息队列、事件分发 | Project Reactor |
| Agent Layer | 核心处理引擎 | Spring AI |
| Provider Layer | LLM 服务适配 | Spring AI + RestTemplate |
| Tool Layer | 工具执行 | Java Process + NIO |
| Channel Layer | 聊天平台接入 | 各平台 SDK |
| Infrastructure | 基础设施 | Spring Boot |

---

## 2. 核心模块设计

### 2.1 消息总线 (Message Bus)

#### 2.1.1 接口定义
```java
/**
 * 消息总线接口
 */
public interface MessageBus {
    /**
     * 发布入站消息（Channel → Agent）
     */
    Mono<Void> publishInbound(Message message);

    /**
     * 发布出站消息（Agent → Channel）
     */
    Mono<Void> publishOutbound(Message message);

    /**
     * 订阅入站消息
     */
    Flux<Message> subscribeInbound();

    /**
     * 订阅出站消息
     */
    Flux<Message> subscribeOutbound();

    /**
     * 订阅特定频道的消息
     */
    Flux<Message> subscribeChannel(String channelId);
}
```

#### 2.1.2 实现类
```java
/**
 * 基于 Reactor 的消息总线实现
 */
@Component
public class ReactorMessageBus implements MessageBus {

    private final Sinks.Many<Message> inboundSink;
    private final Sinks.Many<Message> outboundSink;

    public ReactorMessageBus() {
        this.inboundSink = Sinks.many().multicast().onBackpressureBuffer();
        this.outboundSink = Sinks.many().multicast().onBackpressureBuffer();
    }

    @Override
    public Mono<Void> publishInbound(Message message) {
        return Mono.fromRunnable(() -> inboundSink.tryEmitNext(message));
    }

    @Override
    public Flux<Message> subscribeInbound() {
        return inboundSink.asFlux();
    }

    // ... 其他方法实现
}
```

#### 2.1.3 消息模型
```java
/**
 * 统一消息模型
 */
@Data
@Builder
public class Message {
    private String id;              // 消息唯一ID
    private String channelId;       // 频道ID
    private String channelType;     // 频道类型 (telegram/discord/feishu...)
    private String userId;          // 用户ID
    private String userName;        // 用户名
    private String content;         // 消息内容
    private MessageType type;       // 消息类型 (text/image/file...)
    private Map<String, Object> metadata;  // 元数据
    private Instant timestamp;      // 时间戳

    public enum MessageType {
        TEXT, IMAGE, FILE, COMMAND, SYSTEM
    }
}
```

---

### 2.2 Agent 引擎 (Agent Engine)

#### 2.2.1 AgentLoop
```java
/**
 * Agent 处理循环
 * 负责协调 LLM 调用和工具执行
 */
@Component
public class AgentLoop {

    private final ContextBuilder contextBuilder;
    private final ProviderManager providerManager;
    private final ToolExecutor toolExecutor;
    private final MessageBus messageBus;

    /**
     * 处理单次对话
     */
    public Mono<String> process(Message message, AgentConfig config) {
        return Mono.defer(() -> {
            // 1. 构建上下文
            List<ChatMessage> context = contextBuilder.build(message, config);

            // 2. 获取 Provider
            ChatProvider provider = providerManager.getProvider(config.getModel());

            // 3. 执行处理循环
            return processLoop(context, provider, config, 0);
        });
    }

    /**
     * 处理循环（支持工具调用迭代）
     */
    private Mono<String> processLoop(
            List<ChatMessage> messages,
            ChatProvider provider,
            AgentConfig config,
            int iteration
    ) {
        if (iteration >= config.getMaxIterations()) {
            return Mono.just("达到最大迭代次数");
        }

        return provider.chat(messages, getAvailableTools())
                .flatMap(response -> {
                    if (response.hasToolCalls()) {
                        // 有工具调用，执行工具并继续
                        return executeToolsAndContinue(
                                messages, response, provider, config, iteration + 1
                        );
                    } else {
                        // 最终回复
                        return Mono.just(response.getContent());
                    }
                });
    }

    /**
     * 执行工具并继续循环
     */
    private Mono<String> executeToolsAndContinue(
            List<ChatMessage> messages,
            ChatResponse response,
            ChatProvider provider,
            AgentConfig config,
            int nextIteration
    ) {
        // 添加助手消息（包含工具调用）
        messages.add(response.toMessage());

        // 并行执行所有工具调用
        List<Mono<ToolResult>> toolResults = response.getToolCalls().stream()
                .map(toolCall -> toolExecutor.execute(toolCall)
                        .onErrorResume(e -> Mono.just(ToolResult.error(toolCall.getId(), e)))
                )
                .toList();

        return Flux.merge(toolResults)
                .collectList()
                .flatMap(results -> {
                    // 添加工具结果消息
                    results.forEach(result -> messages.add(result.toMessage()));
                    // 继续下一轮
                    return processLoop(messages, provider, config, nextIteration);
                });
    }
}
```

#### 2.2.2 ContextBuilder
```java
/**
 * 上下文构建器
 * 负责组装系统提示词和对话历史
 */
@Component
public class ContextBuilder {

    private final MemoryManager memoryManager;
    private final SkillManager skillManager;
    private final SystemPromptTemplate promptTemplate;

    /**
     * 构建完整上下文
     */
    public List<ChatMessage> build(Message message, AgentConfig config) {
        List<ChatMessage> messages = new ArrayList<>();

        // 1. 系统提示词
        messages.add(buildSystemPrompt(config));

        // 2. 加载对话历史
        messages.addAll(loadHistory(message, config));

        // 3. 当前用户消息
        messages.add(ChatMessage.user(message.getContent()));

        return messages;
    }

    /**
     * 构建系统提示词
     */
    private ChatMessage buildSystemPrompt(AgentConfig config) {
        Map<String, Object> context = new HashMap<>();
        context.put("currentTime", LocalDateTime.now());
        context.put("workspace", config.getWorkspace());
        context.put("runtime", getRuntimeInfo());
        context.put("memory", memoryManager.getRelevantMemory());
        context.put("alwaysLoadedSkills", skillManager.getAlwaysLoadedSkillsContent());
        context.put("availableSkills", skillManager.getAvailableSkillsSummary());

        String prompt = promptTemplate.render(context);
        return ChatMessage.system(prompt);
    }

    /**
     * 加载对话历史
     */
    private List<ChatMessage> loadHistory(Message message, AgentConfig config) {
        String sessionId = getSessionId(message);
        return SessionStore.getHistory(sessionId, config.getMaxHistory());
    }
}
```

---

### 2.3 Provider 管理器 (Provider Manager)

#### 2.3.1 Provider 注册表
```java
/**
 * Provider 规范定义
 */
@Data
@AllArgsConstructor
public class ProviderSpec {
    private String name;                    // Provider 名称
    private List<String> keywords;          // 匹配关键词
    private String envKey;                  // 环境变量名
    private String litellmPrefix;           // LiteLLM 前缀
    private boolean isGateway;              // 是否为网关
    private String detectByKeyPrefix;       // API Key 前缀检测
    private String baseUrl;                 // 默认 Base URL
}

/**
 * Provider 注册表
 */
@Component
public class ProviderRegistry {

    private final Map<String, ProviderSpec> providers = new ConcurrentHashMap<>();

    public ProviderRegistry() {
        // 注册所有 Provider
        register(new ProviderSpec("glm",
                List.of("glm", "zhipu", "智谱"),
                "GLM_API_KEY",
                "glm",
                false,
                null,
                "https://open.bigmodel.cn/api/paas/v4"
        ));

        register(new ProviderSpec("deepseek",
                List.of("deepseek", "深度求索"),
                "DEEPSEEK_API_KEY",
                "deepseek",
                false,
                "sk-",
                "https://api.deepseek.com/v1"
        ));

        register(new ProviderSpec("qwen",
                List.of("qwen", "dashscope", "通义千问"),
                "DASHSCOPE_API_KEY",
                "qwen",
                false,
                "sk-",
                "https://dashscope.aliyuncs.com/compatible-mode/v1"
        ));

        register(new ProviderSpec("moonshot",
                List.of("moonshot", "kimi", "月之暗面"),
                "MOONSHOT_API_KEY",
                "moonshot",
                false,
                "sk-",
                "https://api.moonshot.cn/v1"
        ));

        // ... 更多 Provider
    }

    public void register(ProviderSpec spec) {
        providers.put(spec.getName(), spec);
    }

    public ProviderSpec getByName(String name) {
        return providers.get(name);
    }

    /**
     * 根据模型名匹配 Provider
     */
    public ProviderSpec matchByModel(String model) {
        return providers.values().stream()
                .filter(spec -> spec.getKeywords().stream()
                        .anyMatch(keyword -> model.toLowerCase().contains(keyword)))
                .findFirst()
                .orElse(getDefaultGateway());
    }

    public ProviderSpec getDefaultGateway() {
        return providers.get("glm");
    }
}
```

#### 2.3.2 Provider 接口
```java
/**
 * Chat Provider 接口
 */
public interface ChatProvider {

    /**
     * 发送聊天请求
     */
    Mono<ChatResponse> chat(List<ChatMessage> messages, List<Tool> tools);

    /**
     * 流式聊天
     */
    Flux<String> chatStream(List<ChatMessage> messages, List<Tool> tools);
}

/**
 * Spring AI 实现封装
 */
@Component
public class SpringAIChatProvider implements ChatProvider {

    private final ChatModel chatModel;

    @Override
    public Mono<ChatResponse> chat(List<ChatMessage> messages, List<Tool> tools) {
        // 转换为 Spring AI 格式
        List<org.springframework.ai.chat.messages.Message> aiMessages =
                convertMessages(messages);

        // 构建请求
        Prompt prompt = new Prompt(aiMessages,
                tools != null ? convertTools(tools) : null);

        // 调用 Spring AI
        return Mono.fromFuture(() -> chatModel.callAsync(prompt))
                .map(this::convertResponse);
    }
}
```

---

### 2.4 工具系统 (Tool System)

#### 2.4.1 工具接口
```java
/**
 * 工具接口
 */
public interface Tool {

    /**
     * 工具名称（用于 LLM 调用）
     */
    String getName();

    /**
     * 工具描述
     */
    String getDescription();

    /**
     * 参数 Schema (JSON Schema)
     */
    String getParameterSchema();

    /**
     * 执行工具
     */
    Mono<ToolResult> execute(ToolCall call);
}

/**
 * 工具调用结果
 */
@Data
@Builder
public class ToolResult {
    private String toolCallId;
    private boolean success;
    private String content;
    private String error;
}
```

#### 2.4.2 工具注册与执行
```java
/**
 * 工具注册表
 */
@Component
public class ToolRegistry {

    private final Map<String, Tool> tools = new ConcurrentHashMap<>();

    public ToolRegistry(List<Tool> toolBeans) {
        toolBeans.forEach(tool -> register(tool));
    }

    public void register(Tool tool) {
        tools.put(tool.getName(), tool);
    }

    public Tool getTool(String name) {
        return tools.get(name);
    }

    public List<Tool> getAllTools() {
        return new ArrayList<>(tools.values());
    }

    /**
     * 转换为 Spring AI FunctionCallback
     */
    public List<FunctionCallback> toFunctionCallbacks() {
        return tools.values().stream()
                .map(this::toFunctionCallback)
                .toList();
    }
}

/**
 * 工具执行器
 */
@Component
public class ToolExecutor {

    private final ToolRegistry registry;

    public Mono<ToolResult> execute(ToolCall call) {
        return Mono.defer(() -> {
            Tool tool = registry.getTool(call.getFunctionName());
            if (tool == null) {
                return Mono.just(ToolResult.error(
                        call.getId(),
                        new IllegalArgumentException("Tool not found: " + call.getFunctionName())
                ));
            }

            return tool.execute(call)
                    .onErrorResume(e -> Mono.just(ToolResult.error(call.getId(), e)));
        });
    }
}
```

#### 2.4.3 内置工具示例
```java
/**
 * 文件读取工具
 */
@Component
public class ReadFileTool implements Tool {

    private final WorkspaceConfig workspaceConfig;

    @Override
    public String getName() {
        return "read_file";
    }

    @Override
    public String getDescription() {
        return "读取文件内容";
    }

    @Override
    public String getParameterSchema() {
        return """
                {
                    "type": "object",
                    "properties": {
                        "path": {"type": "string", "description": "文件路径"}
                    },
                    "required": ["path"]
                }
                """;
    }

    @Override
    public Mono<ToolResult> execute(ToolCall call) {
        return Mono.fromCallable(() -> {
            String path = call.getArgument("path");

            // 工作区限制检查
            if (workspaceConfig.isRestrictToWorkspace()) {
                workspaceConfig.validatePath(path);
            }

            File file = workspaceConfig.resolveFile(path);
            String content = Files.readString(file.toPath());

            return ToolResult.builder()
                    .toolCallId(call.getId())
                    .success(true)
                    .content(content)
                    .build();
        });
    }
}

/**
 * Shell 执行工具
 */
@Component
public class ExecTool implements Tool {

    private final WorkspaceConfig workspaceConfig;
    private final ShellSecurityConfig securityConfig;

    @Override
    public String getName() {
        return "exec";
    }

    @Override
    public String getDescription() {
        return "执行 Shell 命令";
    }

    @Override
    public Mono<ToolResult> execute(ToolCall call) {
        return Mono.fromCallable(() -> {
            String command = call.getArgument("command");

            // 安全检查
            securityConfig.validateCommand(command);

            // 执行命令
            ProcessBuilder pb = new ProcessBuilder();
            pb.directory(workspaceConfig.getWorkDirectory());
            pb.command("bash", "-c", command);

            Process process = pb.start();

            // 超时控制
            boolean finished = process.waitFor(securityConfig.getTimeout(), TimeUnit.SECONDS);

            if (!finished) {
                process.destroyForcibly();
                throw new TimeoutException("命令执行超时");
            }

            String output = new String(
                    process.getInputStream().readAllBytes(),
                    StandardCharsets.UTF_8
            );

            return ToolResult.builder()
                    .toolCallId(call.getId())
                    .success(true)
                    .content(output)
                    .build();
        });
    }
}
```

---

### 2.5 频道管理 (Channel Manager)

#### 2.5.1 频道接口
```java
/**
 * 频道接口
 */
public interface Channel {

    /**
     * 频道类型
     */
    String getType();

    /**
     * 频道ID
     */
    String getId();

    /**
     * 启动频道
     */
    Mono<Void> start();

    /**
     * 停止频道
     */
    Mono<Void> stop();

    /**
     * 发送消息
     */
    Mono<Void> sendMessage(Message message);

    /**
     * 是否已启用
     */
    boolean isEnabled();
}

/**
 * 频道配置
 */
@Data
@ConfigurationProperties(prefix = "nanobot.channels")
public class ChannelConfig {
    private TelegramConfig telegram;
    private DiscordConfig discord;
    private FeishuConfig feishu;
    // ... 其他频道配置
}

@Data
public static class TelegramConfig {
    private boolean enabled;
    private String botToken;
    private List<Long> allowFrom = List.of();  // 空列表表示允许所有人
}
```

#### 2.5.2 频道管理器
```java
/**
 * 频道管理器
 */
@Component
public class ChannelManager {

    private final Map<String, Channel> channels = new ConcurrentHashMap<>();
    private final MessageBus messageBus;

    @Autowired
    public ChannelManager(
            List<Channel> channelBeans,
            MessageBus messageBus,
            ChannelConfig config
    ) {
        this.messageBus = messageBus;

        // 根据配置注册启用的频道
        channelBeans.forEach(channel -> {
            if (isChannelEnabled(channel, config)) {
                register(channel);
            }
        });
    }

    /**
     * 启动所有已注册频道
     */
    public Mono<Void> startAll() {
        return Flux.fromIterable(channels.values())
                .flatMap(Channel::start)
                .then();
    }

    /**
     * 停止所有频道
     */
    public Mono<Void> stopAll() {
        return Flux.fromIterable(channels.values())
                .flatMap(Channel::stop)
                .then();
    }

    /**
     * 分发出站消息到对应频道
     */
    public void dispatchOutbound(Message message) {
        Channel channel = channels.get(message.getChannelId());
        if (channel != null) {
            channel.sendMessage(message)
                    .doOnError(e -> log.error("发送消息失败: {}", e.getMessage()))
                    .subscribe();
        }
    }
}
```

#### 2.5.3 飞书频道示例
```java
/**
 * 飞书频道实现
 */
@Component
@ConditionalOnProperty(name = "nanobot.channels.feishu.enabled", havingValue = "true")
public class FeishuChannel implements Channel {

    private final FeishuClient client;
    private final FeishuConfig config;
    private final MessageBus messageBus;

    @Override
    public String getType() {
        return "feishu";
    }

    @Override
    public String getId() {
        return "feishu-" + config.getAppId();
    }

    @Override
    public Mono<Void> start() {
        return Mono.fromRunnable(() -> {
            // 启动 WebSocket 长连接
            client.startWebSocket(event -> {
                if (event instanceof MessageEvent) {
                    Message message = convertMessage((MessageEvent) event);

                    // 权限检查
                    if (!isAuthorized(message)) {
                        log.warn("未授权用户: {}", message.getUserId());
                        return;
                    }

                    // 发布到消息总线
                    messageBus.publishInbound(message).subscribe();
                }
            });
        });
    }

    private boolean isAuthorized(Message message) {
        // 企业内部应用默认授权，自建应用需要检查 open_id
        return config.getAuthorizedUsers().isEmpty() ||
                config.getAuthorizedUsers().contains(message.getUserId());
    }

    @Override
    public Mono<Void> sendMessage(Message message) {
        return Mono.fromCallable(() -> {
            client.sendMessage(FeishuSendMessageRequest.builder()
                    .receiveId(message.getUserId())
                    .receiveIdType(ReceiveIdType.OPEN_ID)
                    .msgType(MsgType.TEXT)
                    .content(JsonUtils.toJson(Map.of(
                            "text", message.getContent()
                    )))
                    .build());
            return null;
        });
    }
}
```

---

### 2.6 记忆与会话 (Memory & Session)

#### 2.6.1 记忆管理器
```java
/**
 * 记忆管理器
 */
@Component
public class MemoryManager {

    private final File memoryDir;
    private final File dailyMemoryDir;

    /**
     * 获取相关记忆上下文
     */
    public String getRelevantMemory() {
        StringBuilder sb = new StringBuilder();

        // 长期记忆
        File longTermMemory = new File(memoryDir, "MEMORY.md");
        if (longTermMemory.exists()) {
            sb.append("## 长期记忆\n");
            sb.append(readFile(longTermMemory)).append("\n\n");
        }

        // 今日记忆
        String today = LocalDate.now().format(DateTimeFormatter.ISO_DATE);
        File todayMemory = new File(dailyMemoryDir, today + ".md");
        if (todayMemory.exists()) {
            sb.append("## 今日记忆\n");
            sb.append(readFile(todayMemory)).append("\n\n");
        }

        return sb.toString();
    }

    /**
     * 添加记忆
     */
    public Mono<Void> addMemory(String content, boolean longTerm) {
        return Mono.fromRunnable(() -> {
            File target = longTermMemory
                    ? new File(memoryDir, "MEMORY.md")
                    : new File(dailyMemoryDir, LocalDate.now() + ".md");

            String entry = String.format("[%tT] %s\n",
                    LocalDateTime.now(), content);

            try {
                Files.writeString(target.toPath(),
                        Files.readString(target.toPath()) + entry,
                        StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            } catch (IOException e) {
                log.error("写入记忆失败", e);
            }
        });
    }
}
```

#### 2.6.2 会话存储
```java
/**
 * 会话存储
 */
@Component
public class SessionStore {

    private final File sessionDir;

    /**
     * 获取会话历史
     */
    public List<ChatMessage> getHistory(String sessionId, int maxMessages) {
        File sessionFile = new File(sessionDir, sessionId + ".jsonl");

        if (!sessionFile.exists()) {
            return List.of();
        }

        try {
            return Files.lines(sessionFile.toPath())
                    .reverse()  // 从最新开始
                    .limit(maxMessages)
                    .map(this::parseMessage)
                    .sorted(Comparator.comparing(ChatMessage::getTimestamp))
                    .toList();
        } catch (IOException e) {
            log.error("读取会话历史失败", e);
            return List.of();
        }
    }

    /**
     * 追加消息
     */
    public void appendMessage(String sessionId, ChatMessage message) {
        File sessionFile = new File(sessionDir, sessionId + ".jsonl");

        String json = JsonUtils.toJson(message);

        try {
            Files.writeString(sessionFile.toPath(), json + "\n",
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (IOException e) {
            log.error("保存消息失败", e);
        }
    }
}
```

---

### 2.7 定时任务 (Scheduled Tasks)

#### 2.7.1 定时任务配置
```java
/**
 * 定时任务定义
 */
@Data
@Builder
public class ScheduledTask {
    private String id;
    private String name;
    private String description;
    private TaskType type;          // CRON, INTERVAL, ONCE
    private String expression;       // cron 表达式或间隔秒数或时间戳
    private String prompt;          // 任务提示词
    private boolean enabled;
    private Instant lastRun;
    private Instant nextRun;
}

public enum TaskType {
    CRON,       // 0 9 * * * (每天9点)
    INTERVAL,   // 3600 (每小时)
    ONCE        // 2024-02-11T10:00:00Z
}
```

#### 2.7.2 定时任务调度器
```java
/**
 * 定时任务调度器
 */
@Component
public class TaskScheduler {

    private final Map<String, ScheduledTask> tasks = new ConcurrentHashMap<>();
    private final Map<String, ScheduledFuture<?>> futures = new ConcurrentHashMap<>();
    private final AgentLoop agentLoop;
    private final TaskRepository taskRepository;
    private final ThreadPoolTaskScheduler scheduler;

    @PostConstruct
    public void init() {
        // 加载持久化的任务
        tasks.putAll(taskRepository.loadAll());

        // 启动已启用的任务
        tasks.values().stream()
                .filter(ScheduledTask::isEnabled)
                .forEach(this::scheduleTask);
    }

    /**
     * 添加任务
     */
    public Mono<Void> addTask(ScheduledTask task) {
        return Mono.fromRunnable(() -> {
            tasks.put(task.getId(), task);
            taskRepository.save(task);

            if (task.isEnabled()) {
                scheduleTask(task);
            }
        });
    }

    /**
     * 调度任务
     */
    private void scheduleTask(ScheduledTask task) {
        Runnable runnable = () -> {
            log.info("执行定时任务: {}", task.getName());

            // 创建虚拟消息
            Message message = Message.builder()
                    .id(UUID.randomUUID().toString())
                    .channelType("system")
                    .userId("scheduler")
                    .content(task.getPrompt())
                    .build();

            // 通过 Agent 执行
            agentLoop.process(message, getDefaultAgentConfig())
                    .doOnSuccess(response -> {
                        task.setLastRun(Instant.now());
                        taskRepository.save(task);
                    })
                    .doOnError(e -> log.error("任务执行失败: {}", task.getName(), e))
                    .subscribe();
        };

        ScheduledFuture<?> future = switch (task.getType()) {
            case CRON -> scheduler.schedule(runnable,
                    new CronTrigger(task.getExpression()));

            case INTERVAL -> scheduler.scheduleAtFixedRate(runnable,
                    Duration.ofSeconds(Long.parseLong(task.getExpression())));

            case ONCE -> scheduler.schedule(runnable,
                    Instant.parse(task.getExpression()));
        };

        futures.put(task.getId(), future);
    }
}
```

---

### 2.8 技能系统 (Skill System)

#### 2.8.1 技能元数据
```java
/**
 * 技能元数据
 */
@Data
public class SkillMetadata {
    private String name;
    private String description;
    private String emoji;
    private List<String> requires;  // 依赖的工具或外部命令
    private boolean alwaysLoad;     // 是否始终加载到上下文
}

/**
 * 技能加载器
 */
@Component
public class SkillManager {

    private final File skillsDir;
    private final Map<String, SkillMetadata> skills = new HashMap<>();

    @PostConstruct
    public void loadSkills() {
        if (!skillsDir.exists()) {
            return;
        }

        // 扫描技能目录
        File[] skillFiles = skillsDir.listFiles((dir, name) ->
                name.endsWith(".md"));

        if (skillFiles != null) {
            for (File file : skillFiles) {
                SkillMetadata metadata = parseMetadata(file);
                skills.put(metadata.getName(), metadata);
            }
        }
    }

    /**
     * 解析技能元数据（YAML frontmatter）
     */
    private SkillMetadata parseMetadata(File file) {
        try {
            String content = Files.readString(file.toPath());

            // 提取 YAML frontmatter
            Pattern pattern = Pattern.compile("^---\\n(.*?)\\n---", Pattern.DOTALL);
            Matcher matcher = pattern.matcher(content);

            if (matcher.find()) {
                String yaml = matcher.group(1);
                return YamlParser.parse(yaml, SkillMetadata.class);
            }
        } catch (IOException e) {
            log.error("解析技能失败: {}", file.getName(), e);
        }

        return null;
    }

    /**
     * 获取始终加载的技能内容
     */
    public String getAlwaysLoadedSkillsContent() {
        return skills.values().stream()
                .filter(SkillMetadata::isAlwaysLoad)
                .map(this::loadSkillContent)
                .collect(Collectors.joining("\n\n---\n\n"));
    }

    /**
     * 获取可用技能摘要
     */
    public String getAvailableSkillsSummary() {
        return skills.values().stream()
                .filter(s -> !s.isAlwaysLoad())
                .map(s -> String.format("- %s %s: %s",
                        s.getEmoji(), s.getName(), s.getDescription()))
                .collect(Collectors.joining("\n"));
    }
}
```

---

## 3. 配置系统

### 3.1 配置结构
```yaml
nanobot:
  # Agent 配置
  agents:
    default:
      model: "glm-4-plus"
      workspace: "/Users/xxx/nanobot-workspace"
      maxIterations: 10
      maxHistory: 50
      temperature: 0.7

  # Provider 配置
  providers:
    glm:
      apiKey: "${GLM_API_KEY}"
      baseUrl: "https://open.bigmodel.cn/api/paas/v4"
    deepseek:
      apiKey: "${DEEPSEEK_API_KEY}"
      baseUrl: "https://api.deepseek.com/v1"
    qwen:
      apiKey: "${DASHSCOPE_API_KEY}"
      baseUrl: "https://dashscope.aliyuncs.com/compatible-mode/v1"

  # 频道配置
  channels:
    feishu:
      enabled: true
      appId: "${FEISHU_APP_ID}"
      appSecret: "${FEISHU_APP_SECRET}"
      encryptKey: "${FEISHU_ENCRYPT_KEY}"  # 可选
      verificationToken: "${FEISHU_VERIFICATION_TOKEN}"  # 可选
    wecom:
      enabled: true
      corpId: "${WECOM_CORP_ID}"
      agentId: "${WECOM_AGENT_ID}"
      secret: "${WECOM_SECRET}"
      token: "${WECOM_TOKEN}"
    qq:
      enabled: true
      appId: "${QQ_APP_ID}"
      token: "${QQ_TOKEN}"
    dingtalk:
      enabled: false
      appId: "${DINGTALK_APP_ID}"
      appSecret: "${DINGTALK_APP_SECRET}"

  # 工具配置
  tools:
    restrictToWorkspace: true
    workspace: "/Users/xxx/nanobot-workspace"
    webSearch:
      enabled: true
      provider: "brave"
      apiKey: "${BRAVE_API_KEY}"
    shell:
      timeout: 60
      blockedCommands: ["rm -rf", "format", "dd", "mkfs"]

  # 记忆配置
  memory:
    enabled: true
    directory: "${user.home}/.nanobot/memory"
    dailyDirectory: "${user.home}/.nanobot/memory/daily"

  # 会话配置
  session:
    directory: "${user.home}/.nanobot/sessions"
    maxHistory: 50

  # 技能配置
  skills:
    directory: "${user.home}/.nanobot/skills"

  # 定时任务配置
  cron:
    enabled: true
    storage: "${user.home}/.nanobot/cron"

  # 心跳配置
  heartbeat:
    enabled: true
    interval: "30m"
    file: "${user.home}/.nanobot/HEARTBEAT.md"

  # 网关配置
  gateway:
    host: "0.0.0.0"
    port: 8080
```

### 3.2 配置类
```java
/**
 * 顶层配置类
 */
@Data
@ConfigurationProperties(prefix = "nanobot")
@Component
public class NanobotConfig {

    private AgentsConfig agents;
    private ProvidersConfig providers;
    private ChannelsConfig channels;
    private ToolsConfig tools;
    private MemoryConfig memory;
    private SessionConfig session;
    private SkillsConfig skills;
    private CronConfig cron;
    private HeartbeatConfig heartbeat;
    private GatewayConfig gateway;
}

/**
 * Provider 配置
 */
@Data
@ConfigurationProperties(prefix = "nanobot.providers")
@Component
public class ProvidersConfig {
    private GLMConfig glm;
    private DeepSeekConfig deepseek;
    private QwenConfig qwen;
    // ... 其他 Provider
}

/**
 * 工具配置
 */
@Data
@ConfigurationProperties(prefix = "nanobot.tools")
@Component
public class ToolsConfig {
    private boolean restrictToWorkspace = true;
    private String workspace;
    private WebSearchConfig webSearch;
    private ShellConfig shell;
}

@Data
public static class ShellConfig {
    private int timeout = 60;
    private List<String> blockedCommands = List.of("rm -rf", "format", "dd");
}
```

---

## 4. 部署架构

### 4.1 本地部署
```
┌─────────────────────────────────────────────┐
│              用户本地环境                     │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────┐    ┌──────────────┐      │
│  │ nanobot.jar  │    │ ~/.nanobot/  │      │
│  │              │────│ config.yaml  │      │
│  │              │    │ workspace/   │      │
│  │              │    │ memory/      │      │
│  └──────────────┘    │ sessions/    │      │
│                      └──────────────┘      │
└─────────────────────────────────────────────┘
```

### 4.2 Docker 部署
```dockerfile
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

COPY target/nanobot.jar app.jar

# 创建非 root 用户
RUN addgroup -S nanobot && adduser -S nanobot -G nanobot
USER nanobot

# 挂载点
VOLUME ["/root/.nanobot"]

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 4.3 分布式部署（企业版）
```
┌─────────────────────────────────────────────────────────────────┐
│                        负载均衡器                                │
└─────────────────────────────────────────────────────────────────┘
            │                    │                    │
┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│  nanobot-1        │  │  nanobot-2        │  │  nanobot-3        │
│  (Spring Boot)    │  │  (Spring Boot)    │  │  (Spring Boot)    │
└───────────────────┘  └───────────────────┘  └───────────────────┘
            │                    │                    │
└─────────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────────┐
│                      共享存储                                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │ Redis    │  │ MySQL    │  │ MinIO    │  │ Config   │      │
│  │ (会话)    │  │ (记忆)    │  │ (文件)    │  │ (配置)    │      │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 项目结构

```
nanobot-java/
├── pom.xml                                    # Maven 配置
├── src/
│   ├── main/
│   │   ├── java/org/nanobot/
│   │   │   ├── NanobotApplication.java       # 启动类
│   │   │   ├── agent/                        # Agent 核心引擎
│   │   │   │   ├── AgentLoop.java            # 处理循环
│   │   │   │   ├── ContextBuilder.java       # 上下文构建
│   │   │   │   ├── memory/                   # 记忆管理
│   │   │   │   └── subagent/                 # 子 Agent
│   │   │   ├── bus/                          # 消息总线
│   │   │   │   └── MessageBus.java
│   │   │   ├── channel/                      # 频道接入
│   │   │   │   ├── Channel.java             # 频道接口
│   │   │   │   ├── ChannelManager.java      # 频道管理器
│   │   │   │   ├── telegram/                # Telegram 实现
│   │   │   │   ├── discord/                 # Discord 实现
│   │   │   │   └── ...
│   │   │   ├── provider/                     # LLM Provider
│   │   │   │   ├── ProviderRegistry.java    # Provider 注册表
│   │   │   │   ├── ChatProvider.java        # Provider 接口
│   │   │   │   └── impl/                     # 各 Provider 实现
│   │   │   ├── tool/                         # 工具系统
│   │   │   │   ├── Tool.java                # 工具接口
│   │   │   │   ├── ToolRegistry.java        # 工具注册表
│   │   │   │   ├── ToolExecutor.java        # 工具执行器
│   │   │   │   └── builtin/                 # 内置工具
│   │   │   │       ├── FileTool.java
│   │   │   │       ├── ShellTool.java
│   │   │   │       ├── WebTool.java
│   │   │   │       └── MessageTool.java
│   │   │   ├── skill/                        # 技能系统
│   │   │   │   ├── SkillManager.java        # 技能管理器
│   │   │   │   └── SkillMetadata.java
│   │   │   ├── session/                      # 会话管理
│   │   │   │   ├── SessionStore.java        # 会话存储
│   │   │   │   └── SessionManager.java      # 会话管理器
│   │   │   ├── cron/                         # 定时任务
│   │   │   │   ├── TaskScheduler.java       # 任务调度器
│   │   │   │   └── ScheduledTask.java       # 任务定义
│   │   │   ├── heartbeat/                    # 心跳服务
│   │   │   │   └── HeartbeatService.java
│   │   │   ├── config/                       # 配置系统
│   │   │   │   ├── NanobotConfig.java       # 配置类
│   │   │   │   └── ProviderSpec.java
│   │   │   ├── cli/                          # 命令行
│   │   │   │   ├── NanobotCommand.java      # 主命令
│   │   │   │   ├── AgentCommand.java        # Agent 命令
│   │   │   │   └── GatewayCommand.java      # Gateway 命令
│   │   │   ├── api/                          # HTTP API
│   │   │   │   ├── GatewayController.java   # 网关控制器
│   │   │   │   └── MessageController.java   # 消息控制器
│   │   │   └── model/                        # 数据模型
│   │   │       ├── Message.java
│   │   │       ├── ChatMessage.java
│   │   │       └── ToolCall.java
│   │   └── resources/
│   │       ├── application.yaml              # 默认配置
│   │       ├── prompts/                      # 提示词模板
│   │       │   └── system-prompt.ftl
│   │       └── bootstrap/                    # 引导文件模板
│   │           ├── AGENTS.md
│   │           ├── SOUL.md
│   │           ├── USER.md
│   │           └── TOOLS.md
│   └── test/
│       └── java/org/nanobot/
│           ├── agent/                        # Agent 测试
│           ├── provider/                     # Provider 测试
│           └── tool/                         # 工具测试
└── docs/                                      # 文档
    ├── README.md
    ├── CONTRIBUTING.md
    └── API.md
```

---

## 6. 技术决策

### 6.1 为什么选择 Spring AI

| 特性 | Spring AI | LangChain4j |
|------|-----------|-------------|
| Spring 生态集成 | 原生支持 | 需要适配 |
| 函数调用 | 支持 | 支持 |
| 响应式编程 | 原生支持 | 有限支持 |
| 文档质量 | 官方维护 | 社区维护 |
| 企业特性 | 配套完善 | 需自建 |

**决策**：Spring AI 是更好的选择，因为：
- 与 Spring Boot 无缝集成
- 官方支持，长期维护有保障
- 天然支持企业级特性

### 6.2 响应式 vs 传统阻塞

**选择**：Project Reactor（响应式）

**原因**：
- 消息总线需要背压控制
- 多个工具调用可以并行执行
- 更好的资源利用率
- 易于扩展为流式响应

### 6.3 配置存储

| 方案 | 优点 | 缺点 |
|------|------|------|
| 文件 (YAML) | 简单、可移植 | 无热更新 |
| 数据库 | 可集中管理 | 依赖外部服务 |
| 配置中心 (Nacos) | 企业级 | 复杂度高 |

**决策**：文件为主，可选集成配置中心

---

## 7. 质量保证

### 7.1 测试策略
```java
/**
 * AgentLoop 测试
 */
@SpringBootTest
class AgentLoopTest {

    @MockBean
    private ChatProvider provider;

    @Autowired
    private AgentLoop agentLoop;

    @Test
    void shouldProcessSimpleMessage() {
        // Given
        Message message = createTestMessage();
        ChatResponse response = ChatResponse.text("Hello!");

        when(provider.chat(any(), any())).thenReturn(Mono.just(response));

        // When
        StepVerifier.create(agentLoop.process(message, config))
                .expectNext("Hello!")
                .verifyComplete();
    }

    @Test
    void shouldHandleToolCalls() {
        // Given
        Message message = createTestMessage();
        ChatResponse response1 = ChatResponse.withToolCalls(...);
        ChatResponse response2 = ChatResponse.text("Done!");

        when(provider.chat(any(), any()))
                .thenReturn(Mono.just(response1))
                .thenReturn(Mono.just(response2));

        // When & Then
        StepVerifier.create(agentLoop.process(message, config))
                .expectNext("Done!")
                .verifyComplete();
    }
}
```

### 7.2 健康检查
```java
/**
 * 健康检查指示器
 */
@Component
public class NanobotHealthIndicator implements HealthIndicator {

    private final ProviderRegistry providerRegistry;

    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();

        // 检查 Provider 状态
        List<String> availableProviders = providerRegistry.getAvailableProviders();
        builder.withDetail("providers", availableProviders);

        if (availableProviders.isEmpty()) {
            builder.down();
        } else {
            builder.up();
        }

        return builder.build();
    }
}
```

### 7.3 指标暴露
```java
/**
 * 自定义指标
 */
@Component
public class NanobotMetrics {

    private final MeterRegistry meterRegistry;
    private final Counter messageCounter;
    private final Timer processingTimer;

    public NanobotMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.messageCounter = Counter.builder("nanobot.messages.total")
                .tag("channel", "all")
                .register(meterRegistry);
        this.processingTimer = Timer.builder("nanobot.processing.duration")
                .register(meterRegistry);
    }
}
```

---

## 8. 安全设计

### 8.1 工作区限制
```java
/**
 * 工作区路径校验
 */
@Component
public class WorkspaceValidator {

    private final Path workspaceRoot;

    public void validatePath(String userPath) {
        Path resolved = workspaceRoot.resolve(userPath).normalize();

        if (!resolved.startsWith(workspaceRoot)) {
            throw new SecurityException(
                    "路径超出工作区范围: " + userPath
            );
        }
    }
}
```

### 8.2 命令安全检查
```java
/**
 * Shell 命令安全检查
 */
@Component
public class ShellSecurityValidator {

    private final List<Pattern> blockedPatterns;

    public void validateCommand(String command) {
        for (Pattern pattern : blockedPatterns) {
            if (pattern.matcher(command).find()) {
                throw new SecurityException(
                        "禁止的命令: " + command
                );
            }
        }
    }
}
```

### 8.3 API Key 管理
```java
/**
 * API Key 脱敏
 */
@Component
public class ApiKeyMasker {

    private static final Pattern KEY_PATTERN = Pattern.compile(
            "(sk-[a-zA-Z0-9]{4})[a-zA-Z0-9]+([a-zA-Z0-9]{4})"
    );

    public String mask(String apiKey) {
        return KEY_PATTERN.matcher(apiKey)
                .replaceAll("$1****$2");
    }
}
```

---

## 9. 扩展点

### 9.1 新增 Provider（2步）
```java
// 1. 在注册表中添加
public class ProviderRegistry {
    public ProviderRegistry() {
        register(new ProviderSpec("newprovider",
                List.of("newprovider", "np"),
                "NEWPROVIDER_API_KEY",
                "newprovider",
                false,
                "sk-np-",
                "https://api.newprovider.com/v1"
        ));
    }
}

// 2. 添加配置项
@ConfigurationProperties(prefix = "nanobot.providers")
public class ProvidersConfig {
    private NewProviderConfig newprovider;
}
```

### 9.2 新增 Channel
```java
@Component
@ConditionalOnProperty(name = "nanobot.channels.newchannel.enabled", havingValue = "true")
public class NewChannel implements Channel {

    @Override
    public String getType() {
        return "newchannel";
    }

    // 实现接口方法
}
```

### 9.3 新增 Tool
```java
@Component
public class NewTool implements Tool {

    @Override
    public String getName() {
        return "new_tool";
    }

    @Override
    public Mono<ToolResult> execute(ToolCall call) {
        // 实现逻辑
    }
}
```

---

## 10. 附录

### 10.1 依赖版本
```xml
<properties>
    <java.version>17</java.version>
    <spring-boot.version>3.3.0</spring-boot.version>
    <spring-ai.version>1.0.0-M4</spring-ai.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <dependency>
        <groupId>info.picocli</groupId>
        <artifactId>picocli-spring-boot-starter</artifactId>
    </dependency>
</dependencies>
```

### 10.2 参考资料
- [Spring AI Reference](https://docs.spring.io/spring-ai/reference/)
- [Nanobot Python](https://github.com/nanobot-framework/nanobot)
- [Reactor Core](https://projectreactor.io/docs)
